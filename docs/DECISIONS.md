# Технические компромиссы и решения

В этом документе зафиксированы осознанные архитектурные компромиссы проекта. Здесь объясняется не только **что** было сделано, но и самое главное - **почему** были выбраны именно эти решения вместо академически правильных. Цель - показать выбор подходов, которые эффективно работают в условиях реального приложения на Yii2.

## 1. Отказ от Transactional Outbox

**Контекст**: публикация доменных событий (например, `BookStatusChangedEvent`) происходит через механизм `afterCommit` транзакции базы данных.

**Проблема**: существует теоретический риск «двойной записи» (Dual Write). Если процесс PHP упадет ровно в момент между коммитом в БД и отправкой сообщения в очередь, событие будет безвозвратно потеряно.

**Решение**: используется упрощенный подход с `afterCommit` в `TransactionalEventPublisher`.

**Обоснование**: внедрение полноценного паттерна Outbox (с отдельной таблицей событий и фоновым реле) для простого каталога книг является избыточным усложнением инфраструктуры. Уровень критичности уведомлений в данном проекте допускает риск редких потерь в пользу значительного упрощения кода.

## 2. Использование Integer ID вместо UUID

**Контекст**: сущности используют стандартные автоинкрементные `int` идентификаторы на уровне базы данных.

**Проблема**: отсутствие Identity у объекта в памяти до момента сохранения в БД усложняет работу с событиями и сравнение сущностей.

**Решение**: оставлены классические `int` ключи.

**Обоснование**: UUIDv4 или UUIDv7 заметно увеличивают размер индексов и делают URL-адреса громоздкими. Для монолитного приложения с одной БД производительность и читаемость `int` перевешивают академические плюсы UUID. Проблема «Identity в домене до сохранения» решена через стандарт рефлексии (см. пункт 4), что позволяет сохранить чистоту API доменных сущностей.

## 3. Группировка обработчиков по сущностям

**Контекст**: командные обработчики (например, `BookCommandHandler`) содержат методы для всех основных операций модуля (Create, Update, Delete, ChangeStatus).

**Проблема**: формальное нарушение SRP (Single Responsibility Principle) на уровне класса, так как один класс отвечает за несколько разных бизнес-действий.

**Решение**: выбрана группировка методов по смыслу в рамках одного `final readonly` класса-обработчика. Маппинг форм в команды вынесен в отдельный `CommandMapper`, а запуск Use Cases делегируется `WebOperationRunner`.

**Обоснование**: приоритетом в данном проекте является высокая сцепленность (High Cohesion). Эффективнее видеть все команды конкретного модуля в одном файле, чем управлять десятком мелких классов по 10–15 строк кода. Это упрощает навигацию и снижает когнитивную нагрузку при разработке.

## 4. Рефлексия для установки идентификаторов

**Контекст**: идентификаторы сущностей генерируются базой данных при вставке записи.

**Проблема**: открытие публичного метода `setId()` в доменном слое нежелательно, так как это нарушает инкапсуляцию и позволяет менять личность объекта. При этом репозиторию необходимо установить полученный от БД ID в свойство сущности.

**Решение**: используется PHP Reflection API (через `IdentityAssignmentTrait`) в слое инфраструктуры для установки значения в приватное свойство `$id`.

**Обоснование**: это гарантирует «девственную» чистоту домена - у сущностей отсутствуют технические методы, которые не несут бизнес-смысла. Данный подход является проверенным стандартом в таких инструментах, как Doctrine ORM.

## 5. Автоматическое внедрение зависимостей (autowiring) для компонентов Yii2

**Контекст**: стандартный DI-контейнер Yii2 не умеет автоматически разрешать компоненты приложения (db, redis, cache), если они объявлены просто как ID в конфигурации.

**Проблема**: попытка зарегистрировать компонент в контейнере через замыкание `fn() => Yii::$app->db` часто приводит к бесконечной рекурсии, если класс компонента совпадает с типом в конструкторе.

**Решение**: внедрены специальные классы-обертки в `infrastructure/components` (например, `AppDbConnection extends Connection`). В конфигурации Yii используются эти обертки, а в DI-контейнер базовые типы (`Connection::class`) привязаны к вызовам компонентов через `Yii::$app->get()`.

**Обоснование**: это позволяет использовать полноценный Autowiring для всех стандартных инструментов Yii во всех слоях приложения, не раздувая конфигурацию контейнера ручными привязками. Разрыв рекурсии через наследование - это осознанный хак, необходимый для комфортной работы с DI в рамках Yii2.

## 6. DI в фоновых задачах через Handler Registry

**Контекст**: стандартный компонент `yii2-queue` сериализует объекты задач, что делает невозможным внедрение зависимостей через конструктор класса Job.

**Проблема**: использование `Yii::$container->get()` напрямую внутри задач (Service Locator) - это плохая практика, а передача сервисов в конструктор невозможна из-за ограничений сериализации.

**Решение**: реализован паттерн, близкий к Command Bus. Сами задачи - это легкие DTO, а вся логика вынесена в отдельные обработчики (Handlers). Очередь расширена классом `HandlerAwareQueue`, который предоставляет доступ к реестру `JobHandlerRegistry`. Реестр, в свою очередь, использует DI-контейнер для ленивой загрузки нужного обработчика.

**Обоснование**: это решение гарантирует чистоту зависимостей даже в асинхронной среде. Использование контейнера внутри реестра оправдано, так как он выступает в роли специализированной фабрики, позволяя избежать перегрузки конструктора очереди всеми возможными обработчиками системы.

### 7. ActiveRecord в репозиториях (инфраструктура)

**Контекст**: использование `yii\db\ActiveRecord` для общения с базой данных.

**Проблема**: ActiveRecord часто называют антипаттерном в «чистой архитектуре» из-за смешивания логики и хранения.

**Решение**: используется вся мощь `ActiveRecord`, но **только внутри инфраструктурного слоя**. Конфликты оптимистической блокировки (`StaleObjectException`) транслируются в доменные исключения (`StaleDataException`).

**Обоснование**: зачем писать SQL руками или городить сложные Query Builders, если Yii уже отлично это делает? Используются нативные связи (`with`), чтобы не было проблем N+1, но на выходе из репозитория всегда отдаются чистые объекты (DTO или сущности), а не модели фреймворка.

### 8. Компоненты Yii2 в вебе

**Контекст**: использование `ActiveForm`, виджетов и форматов ответов Yii2 в слое представления.

**Проблема**: привязка UI к фреймворку.

**Решение**: оставлены стандартные инструменты Yii2 в контроллерах и вьюхах.

**Обоснование**: эти инструменты экономят время при верстке и обработке форм. Главное, что доменный слой и Use Cases про них ничего не знают. Это допустимый компромисс между скоростью разработки и чистотой слоев.

### 9. Валидация без фанатизма

**Контекст**: распределение логики проверки данных.

**Проблема**: дублирование валидации или создание сотен мелких классов-валидаторов.

**Решение**: если проверка простая (формат, обязательное поле) — её делает форма. ISBN-формат проверяется кастомным `IsbnValidator`. Уникальность ISBN проверяется в `CreateBookUseCase` через QueryService, а на финальном уровне — уникальным индексом в базе через `persist()`. Бизнес-правила (статусные переходы, валидация авторов) — в доменных сущностях.

**Обоснование**: прагматичный подход позволяет избежать «взрыва» количества классов, сохраняя надежность системы там, где это действительно важно.

### 10. Упрощенная авторизация (Showcase mode)

**Контекст**: аутентификация пользователей.

**Проблема**: внедрение сложного RBAC/Identity Management в демонстрационном проекте.

**Решение**: учетные данные администратора временно оставлены в коде, а пароли проверяются упрощенно.

**Обоснование**: фокус проекта - архитектура бизнес-логики (Books, Authors), а не инфраструктура авторизации. Это позволяет запустить проект «из коробки» без сложной настройки, что критично для Architectural Showcase.

## 11. Прагматичный маппинг DTO через ActiveRecord

**Контекст**: использование `jolicode/automapper` для преобразования объектов инфраструктуры (ActiveRecord) в DTO слоя приложения (Read DTO).

**Проблема**: создание отдельных классов-трансформеров для каждого сложного поля (например, списка ID авторов или форматирования статусов) приводит к «взрыву» количества мелких файлов в инфраструктуре, что усложняет навигацию и поддержку.

**Решение**: логика трансформации данных вынесена непосредственно в методы-геттеры ActiveRecord моделей (слой `infrastructure/persistence`), помеченные атрибутами `#[MapTo]`.

**Обоснование**: это решение следует принципу **KISS**. Поскольку ActiveRecord в инфраструктурном слое уже является «тяжелым» объектом, знающим о структуре БД, добавление в него методов для подготовки данных к выдаче в DTO не нарушает архитектурных границ (слой Infrastructure вправе зависеть от слоя Application). Это позволяет избежать избыточной сложности с внешними трансформерами, сохраняя при этом Query-сервисы лаконичными, а Доменный слой - на 100% чистым.

## 12. Декларативная гидрация Entity в ActiveRecord (Write-Side)

**Контекст**: сохранение доменных сущностей в базу данных через ActiveRecord в репозиториях.

**Проблема**: императивное перекладывание полей (`$ar->x = $e->x->value`) создает рутину, а полноценные мапперы (AutoMapper) слишком тяжелы и требуют сложной настройки для Value Objects и ActiveRecord.

**Решение**: используется **ActiveRecordHydrator** - легковесный компонент для декларативного маппинга. Он автоматически выполняет "умный анбоксинг" Value Objects (публичное свойство `value`) и BackedEnums (например, `BookStatus::Published` → `'published'`), позволяя описывать правила сохранения в виде лаконичных массивов.

**Обоснование**:

1.  **Прозрачность**: отсутствие скрытой магии AutoMapper. Все трансформации (Closures) описаны прямо в репозитории.
2.  **Производительность**: гидратор оптимизирован через `get_object_vars` для быстрого доступа к свойствам без накладных расходов рефлексии в большинстве случаев.
3.  **KISS**: решение занимает один небольшой класс и на 100% покрывает потребности проекта, избавляя от зависимости от тяжелых библиотек маппинга на стороне записи.

## 13. Использование Infrastructure Kernel (базовые классы)

**Контекст**: реализация типовых операций (CRUD, пагинация, Identity Map) в слое инфраструктуры.

**Проблема**: следование академическим правилам DDD («репозиторий - это только интерфейс») часто приводит к взрывному росту дублирующегося кода в конкретных реализациях. Это повышает стоимость поддержки и риск ошибок при копипасте.

**Решение**: внедрение «инфраструктурного ядра» (Infrastructure Kernel) в виде абстрактных базовых классов (`BaseActiveRecordRepository`, `BaseQueryService`).

**Обоснование**:

1.  **Борьба с бойлерплейтом**: базовые классы берут на себя техническую рутину (управление Identity Map, трансляция исключений БД, обработка `StaleObjectException` → `StaleDataException`, настройка пагинации), оставляя конкретным классам только логику маппинга.
2.  **Чистота домена**: использование базовых классов ограничено только слоем infrastructure. Доменный слой и слой приложения ничего не знают об этих абстракциях и зависят только от чистых интерфейсов.
3.  **Единообразие**: общие механизмы (например, Identity Map) работают идентично во всех репозиториях, что делает поведение системы предсказуемым.
4.  **Прагматизм**: это «проектный стандарт», который делает Clean Architecture жизнеспособной в условиях реальной разработки, снижая Accidental Complexity без ущерба для гибкости.

## 14. Доступ Presentation к доменным Value Objects и Enums (DomainShared)

**Контекст**: слой Presentation использует доменные перечисления (`BookStatus`) и Value Objects напрямую — в контроллерах, виджетах и обработчиках команд.

**Проблема**: строгая конфигурация Deptrac разрешала Presentation зависеть только от Application. Прямой импорт `BookStatus` из домена блокировался, что вынуждало использовать магические строки (`'published'`, `'draft'`) вместо типобезопасного enum.

**Решение**: в `deptrac.yaml` слою Presentation разрешена зависимость от `DomainShared` — коллектора, включающего `domain/values`, `domain/events` и `domain/exceptions`. Зависимость от `DomainEntities` (сущности с поведением) по-прежнему запрещена.

**Обоснование**:

1.  **Архитектурная корректность**: Clean Architecture разрешает зависимость внешних слоёв от внутренних. `DomainShared` — это «shared kernel»: стабильные, иммутабельные типы без побочных эффектов.
2.  **Типобезопасность**: использование `BookStatus::Published` вместо строки `'published'` исключает класс ошибок, невидимых для статического анализа.
3.  **KISS и DRY**: альтернатива — дублирование enum в Application-слое или оборачивание в DTO — создаёт бессмысленную прослойку без добавленной ценности.
4.  **Контролируемое ослабление**: доступ открыт только к значениям и исключениям, но не к сущностям. Presentation не может вызвать `$book->transitionTo()` — только передать `BookStatus` enum в команду.

## 15. Query Services только в Infrastructure

**Контекст**: в CQRS read-side реализуется через порты (`BookFinderInterface`, `BookSearcherInterface`) и их инфраструктурные реализации.

**Проблема**: дублирование слоя — application-level Query Service, который лишь делегирует к портам, не участвует в runtime (контейнер резолвит `BookQueryServiceInterface` в `infrastructure/queries/BookQueryService`). Это создаёт ghost-компоненты, размывающие границы CQRS.

**Решение**: Query Services реализуются только в `infrastructure/queries/`. В `application/{{module}}/queries/` остаются только Read DTO (например, `BookReadDto`). Presentation и Use Cases зависят от портов, контейнер привязывает порты к инфраструктурным реализациям.

**Обоснование**: один источник истины для read-side. Избегаем «слоя для вида» без реального участия в production-потоке.
