# Технические компромиссы и решения

В этом документе зафиксированы осознанные архитектурные компромиссы проекта. Здесь объясняется не только **что** было сделано, но и самое главное — **почему** были выбраны именно эти решения вместо академически правильных. Цель — показать выбор подходов, которые эффективно работают в условиях реального приложения на Yii2.

## 1. Отказ от Transactional Outbox

**Контекст**: публикация доменных событий происходит через механизм `afterCommit` транзакции базы данных.

**Проблема**: существует теоретический риск «двойной записи» (Dual Write). Если процесс PHP упадет ровно в момент между коммитом в БД и отправкой сообщения в очередь, событие будет безвозвратно потеряно.

**Решение**: используется упрощенный подход с `afterCommit` в `TransactionalEventPublisher`.

**Обоснование**: внедрение полноценного паттерна Outbox (с отдельной таблицей событий и фоновым реле) для простого каталога книг является избыточным усложнением инфраструктуры. Уровень критичности уведомлений в данном проекте допускает риск редких потерь в пользу значительного упрощения кода.

## 2. Использование Integer ID вместо UUID

**Контекст**: сущности используют стандартные автоинкрементные `int` идентификаторы на уровне базы данных.

**Проблема**: отсутствие Identity у объекта в памяти до момента сохранения в БД усложняет работу с событиями и сравнение сущностей.

**Решение**: оставлены классические `int` ключи.

**Обоснование**: UUIDv4 или UUIDv7 заметно увеличивают размер индексов и делают URL-адреса громоздкими. Для монолитного приложения с одной БД производительность и читаемость `int` перевешивают академические плюсы UUID. Проблема «Identity в домене до сохранения» решена через стандарт рефлексии (см. пункт 4), что позволяет сохранить чистоту API доменных сущностей.

## 3. Группировка обработчиков по сущностям

**Контекст**: командные обработчики (например, `BookCommandHandler`) содержат методы для всех основных операций модуля (Create, Update, Delete, Publish).

**Проблема**: формальное нарушение SRP (Single Responsibility Principle) на уровне класса, так как один класс отвечает за несколько разных бизнес-действий.

**Решение**: выбрана группировка методов по смыслу в рамках одного класса-обработчика.

**Обоснование**: приоритетом в данном проекте является высокая сцепленность (High Cohesion). Намного эффективнее видеть все команды конкретного модуля в одном файле, чем управлять десятком мелких классов по 10–15 строк кода. Это упрощает навигацию и снижает когнитивную нагрузку при разработке.

## 4. Рефлексия для установки идентификаторов

**Контекст**: идентификаторы сущностей генерируются базой данных при вставке записи.

**Проблема**: открытие публичного метода `setId()` в доменном слое нежелательно, так как это нарушает инкапсуляцию и позволяет менять личность объекта. При этом репозиторию необходимо установить полученный от БД ID в свойство сущности.

**Решение**: используется PHP Reflection API (через `IdentityAssignmentTrait`) в слое инфраструктуры для установки значения в приватное свойство `$id`.

**Обоснование**: это гарантирует «девственную» чистоту домена — у сущностей отсутствуют технические методы, которые не несут бизнес-смысла. Данный подход является проверенным стандартом в таких инструментах, как Doctrine ORM.

## 5. Автоматическое внедрение зависимостей (autowiring) для компонентов Yii2

**Контекст**: стандартный DI-контейнер Yii2 не умеет автоматически разрешать компоненты приложения (db, redis, cache), если они объявлены просто как ID в конфигурации.

**Проблема**: попытка зарегистрировать компонент в контейнере через замыкание `fn() => Yii::$app->db` часто приводит к бесконечной рекурсии, если класс компонента совпадает с типом в конструкторе.

**Решение**: внедрены специальные классы-обертки в `infrastructure/components` (например, `AppDbConnection extends Connection`). В конфигурации Yii используются эти обертки, а в DI-контейнер базовые типы (`Connection::class`) привязаны к вызовам компонентов через `Yii::$app->get()`.

**Обоснование**: это позволяет использовать полноценный Autowiring для всех стандартных инструментов Yii во всех слоях приложения, не раздувая конфигурацию контейнера ручными привязками. Разрыв рекурсии через наследование — это осознанный хак, необходимый для комфортной работы с DI в рамках Yii2.

## 6. DI в фоновых задачах через Handler Registry

**Контекст**: стандартный компонент `yii2-queue` сериализует объекты задач, что делает невозможным внедрение зависимостей через конструктор класса Job.

**Проблема**: использование `Yii::$container->get()` напрямую внутри задач (Service Locator) — это плохая практика, а передача сервисов в конструктор невозможна из-за ограничений сериализации.

**Решение**: реализован паттерн, близкий к Command Bus. Сами задачи — это легкие DTO, а вся логика вынесена в отдельные обработчики (Handlers). Очередь расширена классом `HandlerAwareQueue`, который предоставляет доступ к реестру `JobHandlerRegistry`. Реестр, в свою очередь, использует DI-контейнер для ленивой загрузки нужного обработчика.

**Обоснование**: это решение гарантирует чистоту зависимостей даже в асинхронной среде. Использование контейнера внутри Реестра оправдано, так как он выступает в роли специализированной фабрики, позволяя избежать перегрузки конструктора очереди всеми возможными обработчиками системы.

### 7. ActiveRecord в репозиториях (инфраструктура)

**Контекст**: использование `yii\db\ActiveRecord` для общения с базой данных.

**Проблема**: ActiveRecord часто называют антипаттерном в "чистой архитектуре" из-за смешивания логики и хранения.

**Решение**: используется вся мощь `ActiveRecord`, но **только внутри инфраструктурного слоя**.

**Обоснование**: зачем писать SQL руками или городить сложные Query Builders, если Yii уже отлично это делает? Используются нативные связи (`with`), чтобы не было проблем N+1, но на выходе из репозитория всегда отдаются чистые объекты (DTO или сущности), а не модели фреймворка.

### 8. Компоненты Yii2 в вебе

**Контекст**: использование `ActiveForm`, виджетов и форматов ответов Yii2 в слое представления.

**Проблема**: привязка UI к фреймворку.

**Решение**: оставлены стандартные инструменты Yii2 в контроллерах и вьюхах.

**Обоснование**: эти инструменты экономят время при верстке и обработке форм. Главное, что доменный слой и Use Cases про них ничего не знают. Это допустимый компромисс между скоростью разработки и чистотой слоев.

### 9. Валидация без фанатизма

**Контекст**: распределение логики проверки данных.

**Проблема**: дублирование валидации или создание сотен мелких классов-валидаторов.

**Решение**: если проверка простая (формат почты, обязательное поле) — ее делает форма. Если проверка сложная (бизнес-правила) — ее делает сам домен или репозиторий. К примеру, проверка на уникальность ISBN делается в базе, так как это единственный надежный способ.

**Обоснование**: прагматичный подход позволяет избежать "взрыва" количества классов, сохраняя надежность системы там, где это действительно важно.

### 10. Упрощенная авторизация (Showcase mode)

**Контекст**: аутентификация пользователей.

**Проблема**: внедрение сложного RBAC/Identity Management в демонстрационном проекте.

**Решение**: учетные данные администратора временно оставлены в коде, а пароли проверяются упрощенно.

**Обоснование**: фокус проекта — архитектура бизнес-логики (Books, Authors), а не инфраструктура авторизации. Это позволяет запустить проект "из коробки" без сложной настройки, что критично для Architectural Showcase.

## 11. Прагматичный маппинг DTO через ActiveRecord

**Контекст**: использование `jolicode/automapper` для преобразования объектов инфраструктуры (ActiveRecord) в DTO слоя приложения (Read DTO).

**Проблема**: создание отдельных классов-трансформеров для каждого сложного поля (например, списка ID авторов или форматирования статусов) приводит к «взрыву» количества мелких файлов в инфраструктуре, что усложняет навигацию и поддержку.

**Решение**: логика трансформации данных вынесена непосредственно в методы-геттеры ActiveRecord моделей (слой `infrastructure/persistence`), помеченные атрибутами `#[MapTo]`.

**Обоснование**: это решение следует принципу **KISS**. Поскольку ActiveRecord в инфраструктурном слое уже является «тяжелым» объектом, знающим о структуре БД, добавление в него методов для подготовки данных к выдаче в DTO не нарушает архитектурных границ (слой Infrastructure вправе зависеть от слоя Application). Это позволяет избежать избыточной сложности с внешними трансформерами, сохраняя при этом Query-сервисы лаконичными, а Доменный слой — на 100% чистым.

## 12. Декларативная гидрация Entity в ActiveRecord (Write-Side)

**Контекст**: сохранение доменных сущностей в базу данных через ActiveRecord в репозиториях.

**Проблема**: императивное перекладывание полей (`$ar->x = $e->x->value`) создает рутину, а полноценные мапперы (AutoMapper) слишком тяжелы и требуют сложной настройки для Value Objects и ActiveRecord.

**Решение**: используется **ActiveRecordHydrator** — легковесный компонент для декларативного маппинга. Он автоматически выполняет "умный анбоксинг" Value Objects (публичное свойство `value`) и BackedEnums, позволяя описывать правила сохранения в виде лаконичных массивов.

**Обоснование**:
1.  **Прозрачность**: отсутствие скрытой магии AutoMapper. Все трансформации (Closures) описаны прямо в репозитории.
2.  **Производительность**: гидратор оптимизирован через `get_object_vars` для быстрого доступа к свойствам без накладных расходов рефлексии в большинстве случаев.
3.  **KISS**: решение занимает один небольшой класс и на 100% покрывает потребности проекта, избавляя от зависимости от тяжелых библиотек маппинга на стороне записи.

## 13. Использование Infrastructure Kernel (базовые классы)

**Контекст**: реализация типовых операций (CRUD, пагинация, Identity Map) в слое инфраструктуры.

**Проблема**: следование академическим правилам DDD ("репозиторий — это только интерфейс") часто приводит к взрывному росту дублирующегося кода в конкретных реализациях. Это повышает стоимость поддержки и риск ошибок при копипасте.

**Решение**: внедрение «инфраструктурного ядра» (Infrastructure Kernel) в виде абстрактных базовых классов (`BaseActiveRecordRepository`, `BaseQueryService`).

**Обоснование**:
1.  **Борьба с бойлерплейтом**: базовые классы берут на себя техническую рутину (управление Identity Map, трансляция исключений БД, настройка пагинации), оставляя конкретным классам только логику маппинга.
2.  **Чистота домена**: использование базовых классов ограничено только слоем infrastructure. Доменный слой и слой приложения ничего не знают об этих абстракциях и зависят только от чистых интерфейсов.
3.  **Единообразие**: общие механизмы (например, Identity Map) работают идентично во всех репозиториях, что делает поведение системы предсказуемым.
4.  **Прагматизм**: это «проектный стандарт», который делает Clean Architecture жизнеспособной в условиях реальной разработки, снижая Accidental Complexity без ущерба для гибкости.

