# Architectural Decisions & Trade-offs (ADR)

В этом документе зафиксированы осознанные архитектурные компромиссы и принятые риски.
Мы отдаем приоритет прагматизму и простоте поддержки, а не академической чистоте, где это допустимо.

## 1. Отказ от Transactional Outbox (Dual Write)
- **Контекст:** Публикация доменных событий (`EventPublisher`) происходит внутри `afterCommit` транзакции базы данных.
- **Проблема:** Существует теоретический риск потери события (Dual Write). Если процесс PHP упадет (OOM, Segfault, Power Loss) ровно в момент *после* коммита в БД, но *до* отправки сообщения в очередь — данные в БД сохранятся, а событие не уйдет.
- **Решение:** Мы используем простой `afterCommit` через `TransactionalEventPublisher` вместо внедрения паттерна Transactional Outbox.
- **Обоснование:** Внедрение Outbox требует создания таблицы событий, фонового демона для их пересылки и настройки дедупликации. Для каталога книг риск потери одного уведомления раз в год считается приемлемым ради упрощения инфраструктуры.

## 2. Использование Integer ID вместо UUID
- **Контекст:** Сущности используют автоинкрементные `int` идентификаторы.
- **Проблема:** Сущность не имеет Identity до момента сохранения в БД. Сложнее делать шардинг в будущем.
- **Решение:** Оставить стандартные для Yii2/ActiveRecord `int` ключи.
- **Обоснование:** UUID ухудшают производительность индексов (фрагментация) и читаемость URL. Для монолитного приложения Integer ID — оптимальный стандарт де-факто.

## 3. Redis как хранилище идемпотентности SMS
- **Контекст:** Дедупликация SMS-сообщений (`NotifySingleSubscriberHandler`) использует Redis Cache.
- **Проблема:** Redis может удалить ключи (Eviction) при нехватке памяти, что приведет к повторной отправке SMS.
- **Решение:** Использовать Redis без персистентного хранилища.
- **Обоснование:** SMS-уведомления не являются критической финансовой операцией. Повторная отправка допустима. Использование SQL-таблицы для дедупликации нарушает принцип YAGNI в данном контексте.

## 4. Группировка Handlers по сущностям
- **Контекст:** Командные хендлеры (например, `BookCommandHandler`, `AuthorCommandHandler`) содержат методы для всех операций (Create, Update, Delete).
- **Проблема:** Формальное нарушение Single Responsibility Principle (SRP).
- **Решение:** Группировать методы в один класс Handler, пока он не станет слишком большим.
- **Обоснование:** High Cohesion (высокая сцепленность). Удобнее видеть все команды модуля в одном файле, чем прыгать по 10 файлам из 15 строк.

## 5. Рефлексия для установки ID (DB-side Identity)
- **Контекст:** Сущности используют `int` ID, генерируемые базой данных (Auto-increment).
- **Проблема:** Доменная сущность должна иметь приватный сеттер для ID, чтобы защитить инвариант (ID не должен меняться после присвоения). Репозиторию нужно установить этот ID после `INSERT`.
- **Решение:** Использовать PHP Reflection API в репозиториях для установки приватного свойства `$id`.
- **Обоснование:** Это позволяет сохранить домен «чистым» (без публичных `setId()`, которые не нужны бизнесу) и избежать использования UUID там, где в них нет острой необходимости. Данный подход является стандартом в таких ORM, как Doctrine.
