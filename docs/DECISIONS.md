# Архитектурные решения (ADR)

В этом документе я зафиксировал осознанные архитектурные компромиссы проекта. Моя цель — не слепое следование учебникам по Clean Architecture, а выбор решений, которые будут эффективно работать и легко поддерживаться в условиях реального приложения на Yii2.

## 1. Отказ от Transactional Outbox
**Контекст**: публикация доменных событий происходит через механизм `afterCommit` транзакции базы данных.
**Проблема**: существует теоретический риск «двойной записи» (Dual Write). Если процесс PHP упадет ровно в момент между коммитом в БД и отправкой сообщения в очередь, событие будет безвозвратно потеряно.
**Решение**: я решил использовать упрощенный подход с `afterCommit` в `TransactionalEventPublisher`.
**Обоснование**: внедрение полноценного паттерна Outbox (с отдельной таблицей событий и фоновым реле) для простого каталога книг является избыточным усложнение инфраструктуры. Уровень критичности уведомлений в данном проекте допускает риск редких потерь в пользу значительного упрощения кода.

## 2. Использование Integer ID вместо UUID
**Контекст**: сущности используют стандартные автоинкрементные `int` идентификаторы на уровне базы данных.
**Проблема**: отсутствие Identity у объекта в памяти до момента сохранения в БД усложняет работу с событиями и сравнение сущностей.
**Решение**: я решил оставить классические `int` ключи.
**Обоснование**: UUIDv4 или UUIDv7 заметно увеличивают размер индексов и делают URL-адреса громоздкими. Для монолитного приложения с одной БД производительность и читаемость `int` перевешивают академические плюсы UUID. Проблема «Identity в домене до сохранения» решена через стандарт рефлексии (см. пункт 4), что позволяет сохранить чистоту API доменных сущностей.

## 3. Группировка обработчиков по сущностям
**Контекст**: командные обработчики (например, `BookCommandHandler`) содержат методы для всех основных операций модуля (Create, Update, Delete, Publish).
**Проблема**: формальное нарушение SRP (Single Responsibility Principle) на уровне класса, так как один класс отвечает за несколько разных бизнес-действий.
**Решение**: я выбрал группировку методов по смыслу в рамках одного класса-обработчика.
**Обоснование**: приоритетом в данном проекте является высокая сцепленность (High Cohesion). Намного эффективнее видеть все команды конкретного модуля в одном файле, чем управлять десятком мелких классов по 10–15 строк кода. Это упрощает навигацию и снижает когнитивную нагрузку при разработке.

## 4. Рефлексия для установки идентификаторов
**Контекст**: идентификаторы сущностей генерируются базой данных при вставке записи.
**Проблема**: я категорически не хочу открывать публичный метод `setId()` в доменном слое, так как это нарушает инкапсуляцию и позволяет менять личность объекта. При этом репозиторию необходимо установить полученный от БД ID в свойство сущности.
**Решение**: я использую PHP Reflection API (через `IdentityAssignmentTrait`) в слое инфраструктуры для установки значения в приватное свойство `$id`.
**Обоснование**: это гарантирует «девственную» чистоту домена — у сущностей отсутствуют технические методы, которые не несут бизнес-смысла. Данный подход является проверенным стандартом в таких инструментах, как Doctrine ORM.

## 5. Автоматическое внедрение зависимостей (autowiring) для компонентов Yii2
**Контекст**: стандартный DI-контейнер Yii2 не умеет автоматически разрешать компоненты приложения (db, redis, cache), если они объявлены просто как ID в конфигурации.
**Проблема**: попытка зарегистрировать компонент в контейнере через замыкание `fn() => Yii::$app->db` часто приводит к бесконечной рекурсии, если класс компонента совпадает с типом в конструкторе.
**Решение**: я внедрил специальные классы-обертки в `infrastructure/components` (например, `AppDbConnection extends Connection`). В конфигурации Yii используются эти обертки, а в DI-контейнер базовые типы (`Connection::class`) привязаны к вызовам компонентов через `Yii::$app->get()`.
**Обоснование**: это позволяет использовать полноценный Autowiring для всех стандартных инструментов Yii во всех слоях приложения, не раздувая конфигурацию контейнера ручными привязками. Разрыв рекурсии через наследование — это осознанный хак, необходимый для комфортной работы с DI в рамках Yii2.

## 6. DI в фоновых задачах через Handler Registry
**Контекст**: стандартный компонент `yii2-queue` сериализует объекты задач, что делает невозможным внедрение зависимостей через конструктор класса Job.
**Проблема**: использование `Yii::$container->get()` напрямую внутри задач (Service Locator) — это плохая практика, а передача сервисов в конструктор невозможна из-за ограничений сериализации.
**Решение**: я реализовал паттерн, близкий к Command Bus. Сами задачи — это легкие DTO, а вся логика вынесена в отдельные обработчики (Handlers). Очередь расширена классом `HandlerAwareQueue`, который предоставляет доступ к реестру `JobHandlerRegistry`. Реестр, в свою очередь, использует DI-контейнер для ленивой загрузки нужного обработчика.
**Обоснование**: это решение гарантирует чистоту зависимостей даже в асинхронной среде. Использование контейнера внутри Реестра оправдано, так как он выступает в роли специализированной фабрики, позволяя избежать перегрузки конструктора очереди всеми возможными обработчиками системы.