# Архитектурные решения (ADR)

В этом документе я собрал осознанные компромиссы проекта. Я не ставил целью реализовать "идеальную архитектуру" из учебников, а выбирал решения, которые будут наиболее эффективны при поддержке реального приложения на Yii2.

## 1. Отказ от Transactional Outbox
**Контекст**: публикация доменных событий происходит внутри `afterCommit` транзакции базы данных.
**Проблема**: существует теоретический риск «двойной записи». Если сервер упадет ровно в момент между коммитом в БД и отправкой сообщения в очередь, событие будет потеряно.
**Решение**: я использую простой механизм `afterCommit` в `TransactionalEventPublisher`.
**Обоснование**: внедрение полноценного Outbox (с отдельной таблицей и воркером) для простого каталога книг — это избыточное усложнение. Уровень критичности уведомлений допускает риск редких потерь в пользу простоты инфраструктуры.

## 2. Integer ID вместо UUID
**Контекст**: сущности используют стандартные автоинкрементные `int` идентификаторы.
**Проблема**: отсутствие Identity у сущности до момента сохранения в БД усложняет работу с событиями в памяти.
**Решение**: я решил оставить стандартные `int` ключи.
**Обоснование**: UUIDv4/v7 увеличивают нагрузку на индексы и делают URL менее читаемыми. Для монолита `int` является оптимальным выбором по производительности. Проблема Identity в домене решена через архитектурный стандарт рефлексии (см. пункт 4), что сохраняет чистоту API сущностей.

## 3. Группировка обработчиков по сущностям
**Контекст**: командные обработчики (например, `BookCommandHandler`) содержат методы для всех операций модуля (Create, Update, Delete).
**Проблема**: формальное нарушение SRP (единственной ответственности) на уровне класса.
**Решение**: я группирую методы по смыслу в один класс, пока он не станет слишком громоздким.
**Обоснование**: приоритетом является высокая сцепленность (High Cohesion). Удобнее видеть все команды модуля в одном файле, чем управлять множеством мелких классов по несколько строк кода.

## 4. Рефлексия для установки ID
**Контекст**: идентификаторы генерируются базой данных при вставке.
**Проблема**: я не хочу делать метод `setId()` публичным в домене, так как это нарушает инкапсуляцию. Но репозиторию необходимо проставить ID после сохранения.
**Решение**: я использую рефлексию свойств через `IdentityAssignmentTrait` в слое инфраструктуры.
**Обоснование**: это гарантирует чистоту доменного слоя — у сущностей нет технических методов, не нужных бизнесу. Данный подход является стандартом в современных ORM (например, Doctrine).