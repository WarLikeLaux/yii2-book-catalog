#!/usr/bin/env php
<?php

declare(strict_types=1);

/**
 * Ğ£Ñ‚Ğ¸Ğ»Ğ¸Ñ‚Ğ° Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ° Ğ¸ ĞºÑ€Ğ°ÑĞ¸Ğ²Ğ¾Ğ³Ğ¾ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ° ĞºĞ¾Ğ¼Ğ¼ĞµĞ½Ñ‚Ğ°Ñ€Ğ¸ĞµĞ².
 */

final class CommentLister
{
    private const array EXCLUDE_DIRS = ['vendor', 'tests', 'runtime', 'web/assets', '.git', '.idea'];

    private const string C_RESET = "\033[0m";
    private const string C_RED = "\033[31m";
    private const string C_GREEN = "\033[32m";
    private const string C_YELLOW = "\033[33m";
    private const string C_BLUE = "\033[34m";
    private const string C_CYAN = "\033[36m";
    private const string C_GRAY = "\033[90m";
    private const string C_BOLD = "\033[1m";

    private array $todos = [];
    private array $ignores = [];
    private array $notes = [];

    public function __construct(
        private readonly string $rootPath
    ) {
    }

    public function run(): void
    {
        $iterator = new RecursiveIteratorIterator(
            new RecursiveCallbackFilterIterator(
                new RecursiveDirectoryIterator($this->rootPath, RecursiveDirectoryIterator::SKIP_DOTS),
                function (SplFileInfo $current): bool {
                    if ($current->isDir()) {
                        return !in_array($current->getFilename(), self::EXCLUDE_DIRS, true);
                    }
                    return $current->getExtension() === 'php';
                }
            )
        );

        foreach ($iterator as $file) {
            $this->processFile($file);
        }

        $this->renderOutput();
    }

    private function processFile(SplFileInfo $file): void
    {
        $content = file_get_contents($file->getPathname());
        if ($content === false) {
            return;
        }

        try {
            $tokens = token_get_all($content, TOKEN_PARSE);
        } catch (ParseError) {
            return;
        }

        foreach ($tokens as $token) {
            if (!$this->isCommentToken($token)) {
                continue;
            }

            [$id, $text, $line] = $token;

            if ($this->shouldSkip($text, $id)) {
                continue;
            }

            $relativePath = str_replace($this->rootPath . '/', '', $file->getPathname());
            $cleanText = $this->extractCleanText($text);

            if ($cleanText === '') {
                continue;
            }

            $this->categorize($relativePath, $line, $cleanText);
        }
    }

    private function categorize(string $file, int $line, string $text): void
    {
        $item = ['file' => $file, 'line' => $line, 'text' => $text];

        if (stripos($text, 'TODO') !== false || stripos($text, 'FIXME') !== false) {
            $this->todos[] = $item;
        } elseif (stripos($text, 'codeCoverageIgnore') !== false) {
            $this->ignores[] = $item;
        } else {
            $this->notes[] = $item;
        }
    }

    private function renderOutput(): void
    {
        $this->printSection("ğŸ”´ TODOs & FIXMEs", $this->todos, self::C_RED);
        $this->printSection("ğŸ“ General Notes", $this->notes, self::C_CYAN);
        $this->printSection("ğŸ™ˆ Code Coverage Ignores", $this->ignores, self::C_GRAY);
    }

    private function printSection(string $title, array $items, string $color): void
    {
        if (empty($items)) {
            return;
        }

        echo "\n" . self::C_BOLD . $color . "--- {$title} (" . count($items) . ") ---" . self::C_RESET . "\n";

        foreach ($items as $item) {
            echo self::C_BLUE . $item['file'] . ":" . $item['line'] . self::C_RESET . "\n";
            
            $lines = explode("\n", $item['text']);
            foreach ($lines as $line) {
                echo "  " . $line . "\n";
            }
            echo "\n";
        }
    }

    private function isCommentToken(string|array $token): bool
    {
        return is_array($token) && ($token[0] === T_COMMENT || $token[0] === T_DOC_COMMENT);
    }

    private function shouldSkip(string $text, int $tokenId): bool
    {
        if (str_starts_with($text, '#[')) {
            return true;
        }

        if (str_contains($text, 'region') || str_contains($text, 'endregion')) {
            return true;
        }

        if ($tokenId === T_DOC_COMMENT) {
            return $this->isTechnicalPhpDoc($text);
        }

        return false;
    }

    private function isTechnicalPhpDoc(string $text): bool
    {
        $clean = $this->extractCleanText($text);
        if ($clean === '') {
            return true;
        }

        $lines = explode("\n", $clean);
        foreach ($lines as $line) {
            if ($line === '') continue;
            
            if (str_contains($line, '{@inheritdoc}') || str_contains($line, '@inheritdoc')) continue;
            if (str_contains($line, '@copyright') || str_contains($line, '@license') || str_contains($line, '@author')) continue;

            if (!preg_match('/^@(?:var|param|return|throws|property|deprecated|mixin|method|extends|implements|use|link|codeCoverageIgnore)/', $line)) {
                return false;
            }
            
            if (str_starts_with($line, '@codeCoverageIgnore') && strlen($line) > 20) {
                 return false;
            }
        }

        return true;
    }

    private function extractCleanText(string $text): string
    {
        $clean = preg_replace('~^(\s*(\/\*\*|\*\/|\*|\/\/|#)\s*)+~m', '', $text);
        
        $lines = explode("\n", (string)$clean);
        $result = [];
        foreach ($lines as $line) {
            $trimmed = trim($line);
            if ($trimmed !== '') {
                if ($this->shouldSkipLineInsideComment($trimmed)) {
                    continue;
                }
                $result[] = $trimmed;
            }
        }
        
        return implode("\n", $result);
    }

    private function shouldSkipLineInsideComment(string $line): bool
    {
        if (str_contains($line, '{@inheritdoc}') || str_contains($line, '@inheritdoc')) return true;
        if (str_starts_with($line, '@copyright')) return true;
        
        if (preg_match('/^@(?:var|param|return|throws|property|method|mixin|link)/', $line)) {
            return true;
        }
        
        return false;
    }
}

(new CommentLister(__DIR__ . '/..'))->run();
