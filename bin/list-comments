#!/usr/bin/env php
<?php

declare(strict_types=1);

final class CommentLinter
{
    private const array EXCLUDE_DIRS = [
        'vendor',
        'tests',
        'runtime',
        'web',
        'node_modules',
        'config',
        'docs',
        '.git',
        '.idea',
        'db-data',
        'db-data-pgsql',
    ];
    private const array EXCLUDE_FILES = ['phparkitect.php'];
    private const array SUPPORTED_EXTENSIONS = ['php', 'js', 'mjs'];
    private const string C_RESET = "\033[0m";
    private const string C_RED = "\033[31m";
    private const string C_GREEN = "\033[32m";
    private const string C_BLUE = "\033[34m";
    private const string C_CYAN = "\033[36m";
    private const string C_GRAY = "\033[90m";
    private const string C_BOLD = "\033[1m";

    /** @var list<array{file: string, line: int, text: string}> */
    private array $violations = [];
    /** @var list<array{file: string, line: int, text: string}> */
    private array $notes = [];
    /** @var list<array{file: string, line: int, text: string}> */
    private array $ignores = [];

    public function __construct(
        private readonly string $rootPath,
        private readonly bool $showNotes,
        private readonly bool $showIgnores,
    ) {
    }

    public function run(): int
    {
        $iterator = new RecursiveIteratorIterator(
            new RecursiveCallbackFilterIterator(
                new RecursiveDirectoryIterator($this->rootPath, RecursiveDirectoryIterator::SKIP_DOTS),
                static function (SplFileInfo $current): bool {
                    if ($current->isDir()) {
                        return !in_array($current->getFilename(), self::EXCLUDE_DIRS, true);
                    }

                    if (in_array($current->getFilename(), self::EXCLUDE_FILES, true)) {
                        return false;
                    }

                    return in_array($current->getExtension(), self::SUPPORTED_EXTENSIONS, true);
                },
            ),
        );

        foreach ($iterator as $file) {
            if (!$file->isFile()) {
                continue;
            }

            $extension = $file->getExtension();

            match ($extension) {
                'php' => $this->processPhpFile($file),
                'js', 'mjs' => $this->processJsFile($file),
                default => null,
            };
        }

        return $this->renderOutput();
    }

    private function processPhpFile(SplFileInfo $file): void
    {
        $content = file_get_contents($file->getPathname());

        if ($content === false) {
            return;
        }

        try {
            $tokens = token_get_all($content, TOKEN_PARSE);
        } catch (ParseError) {
            return;
        }

        $relativePath = str_replace($this->rootPath . '/', '', $file->getPathname());

        foreach ($tokens as $token) {
            if (!is_array($token) || ($token[0] !== T_COMMENT && $token[0] !== T_DOC_COMMENT)) {
                continue;
            }

            [$id, $text, $line] = $token;

            if (str_starts_with($text, '#[')
                || str_contains($text, 'region')
                || str_contains($text, 'endregion')
            ) {
                continue;
            }

            if ($id === T_DOC_COMMENT && $this->isTechnicalPhpDoc($text)) {
                continue;
            }

            $cleanText = $this->extractCleanText($text);

            if ($cleanText === '') {
                continue;
            }

            $this->categorize($relativePath, $line, $cleanText);
        }
    }

    private function processJsFile(SplFileInfo $file): void
    {
        $content = file_get_contents($file->getPathname());

        if ($content === false) {
            return;
        }

        $relativePath = str_replace($this->rootPath . '/', '', $file->getPathname());

        if (preg_match_all('~/\*(.+?)\*/~s', $content, $matches, PREG_OFFSET_CAPTURE)) {
            foreach ($matches[1] as [$text, $offset]) {
                $line = substr_count($content, "\n", 0, $offset) + 1;
                $cleanText = $this->extractCleanText('/*' . $text . '*/');

                if ($cleanText !== '') {
                    $this->categorize($relativePath, $line, $cleanText);
                }
            }
        }

        if (preg_match_all('~^\s*//(.*)$~m', $content, $matches, PREG_OFFSET_CAPTURE)) {
            foreach ($matches[1] as [$text, $offset]) {
                $line = substr_count($content, "\n", 0, $offset) + 1;
                $trimmed = trim($text);

                if ($trimmed !== '' && !str_starts_with($trimmed, '!')) {
                    $this->categorize($relativePath, $line, $trimmed);
                }
            }
        }
    }

    private function categorize(string $file, int $line, string $text): void
    {
        $item = ['file' => $file, 'line' => $line, 'text' => $text];

        if (stripos($text, 'codeCoverageIgnore') !== false) {
            $this->ignores[] = $item;
            return;
        }

        if (stripos($text, 'NOTE:') !== false || str_starts_with($text, '@see')) {
            $this->notes[] = $item;
            return;
        }

        if ($this->isTechnicalInlineAnnotation($text)) {
            return;
        }

        $this->violations[] = $item;
    }

    private function isTechnicalInlineAnnotation(string $text): bool
    {
        $prefixes = [
            '@phpcsSuppress',
            '@phpcs:disable',
            '@phpcs:enable',
            '@phpstan-ignore',
            '@phpstan-param',
            '@phpstan-return',
            '@phpstan-type',
            '@phpstan-import-type',
            '@template',
            '@implements',
            '@noRector',
            '@internal',
            'phpcs:disable',
            'phpcs:enable',
            'phpcs:ignore',
            'phpcs:ignoreFile',
        ];

        foreach ($prefixes as $prefix) {
            if (str_starts_with($text, $prefix)) {
                return true;
            }
        }

        return false;
    }

    private function renderOutput(): int
    {
        if ($this->violations !== []) {
            $count = count($this->violations);
            echo "\n" . self::C_BOLD . self::C_RED
                . "‚ùå –ù–ê–ô–î–ï–ù–û {$count} –õ–ò–®–ù–ò–• –ö–û–ú–ú–ï–ù–¢–ê–†–ò–ï–í"
                . self::C_RESET . "\n";

            foreach ($this->violations as $item) {
                echo self::C_RED . $item['file'] . ':' . $item['line'] . self::C_RESET . "\n";

                foreach (explode("\n", $item['text']) as $line) {
                    echo '  ' . $line . "\n";
                }

                echo "\n";
            }
        }

        if ($this->showNotes && $this->notes !== []) {
            $count = count($this->notes);
            echo "\n" . self::C_BOLD . self::C_CYAN
                . "üìù NOTE-–∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ ({$count})"
                . self::C_RESET . "\n";

            $this->printItems($this->notes);
        }

        if ($this->showIgnores && $this->ignores !== []) {
            $count = count($this->ignores);
            echo "\n" . self::C_BOLD . self::C_GRAY
                . "üôà Code Coverage Ignores ({$count})"
                . self::C_RESET . "\n";

            $this->printItems($this->ignores);
        }

        if ($this->violations !== []) {
            echo self::C_BOLD . self::C_RED
                . "–£–¥–∞–ª–∏—Ç–µ –ª–∏—à–Ω–∏–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏. –î–æ–ø—É—Å–∫–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ NOTE: –∏ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –∞–Ω–Ω–æ—Ç–∞—Ü–∏–∏."
                . self::C_RESET . "\n";

            return 1;
        }

        echo "\n" . self::C_BOLD . self::C_GREEN . "‚úÖ –õ–∏—à–Ω–∏—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ." . self::C_RESET . "\n";

        return 0;
    }

    /** @param list<array{file: string, line: int, text: string}> $items */
    private function printItems(array $items): void
    {
        foreach ($items as $item) {
            echo self::C_BLUE . $item['file'] . ':' . $item['line'] . self::C_RESET . "\n";

            foreach (explode("\n", $item['text']) as $line) {
                echo '  ' . $line . "\n";
            }

            echo "\n";
        }
    }

    private function isTechnicalPhpDoc(string $text): bool
    {
        $clean = $this->extractCleanText($text);

        if ($clean === '') {
            return true;
        }

        foreach (explode("\n", $clean) as $line) {
            if ($line === '') {
                continue;
            }

            if (str_contains($line, '{@inheritdoc}') || str_contains($line, '@inheritdoc')) {
                continue;
            }

            if (str_contains($line, '@copyright') || str_contains($line, '@license') || str_contains($line, '@author')) {
                continue;
            }

            if (!preg_match('/^@(?:var|param|return|throws|property|deprecated|mixin|method|extends|implements|use|link|codeCoverageIgnore)/', $line)) {
                return false;
            }

            if (str_starts_with($line, '@codeCoverageIgnore') && strlen($line) > 20) {
                return false;
            }
        }

        return true;
    }

    private function extractCleanText(string $text): string
    {
        $clean = preg_replace('~^(\s*(\/\*\*|\*\/|\*|\/\/|#)\s*)+~m', '', $text);
        $lines = explode("\n", (string)$clean);
        $result = [];

        foreach ($lines as $line) {
            $trimmed = trim($line);

            if ($trimmed === '') {
                continue;
            }

            if ($this->shouldSkipLineInsideComment($trimmed)) {
                continue;
            }

            $result[] = $trimmed;
        }

        return implode("\n", $result);
    }

    private function shouldSkipLineInsideComment(string $line): bool
    {
        if (str_contains($line, '{@inheritdoc}') || str_contains($line, '@inheritdoc')) {
            return true;
        }

        if (str_starts_with($line, '@copyright')) {
            return true;
        }

        return (bool)preg_match('/^@(?:var|param|return|throws|property|method|mixin|link)/', $line);
    }
}

$flags = array_slice($argv, 1);
$showNotes = in_array('--notes', $flags, true) || in_array('--all', $flags, true);
$showIgnores = in_array('--ignores', $flags, true) || in_array('--all', $flags, true);
$linter = new CommentLinter(__DIR__ . '/..', $showNotes, $showIgnores);
exit($linter->run());
